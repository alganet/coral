#!/usr/bin/env sh
# --- 4174138 --- file:module/support
#!/usr/bin/env sh

##
 # require support - silently set sane options for all shells
 ##

# Options for all shells
#
# -e: Exit if any command has an uncaught error code
# -u: Exit on any use of an undefined variable
# -f: Do not expand glob patterns
set -euf

# Mimic local variables on ksh by aliasing it to typeset
#
# This command is ignored by shells other than ksh
#
if ( test -n "${KSH_VERSION:-}" &&
     test -z "${KSH_VERSION##*Version AJM*}" ) ||
     test -n "${YASH_VERSION:-}"
then
	alias local=typeset
elif test -n "${BASH_VERSION-}"
then
	set -o posix
elif test -n "${ZSH_VERSION-}"
then
	# Unset options for zsh to make it more portable
	#
	# NO_MATCH: Avoid expanding extra filename patterns
	# NO_SH_WORD_SPLIT: Make the word split on zsh behave like POSIX
	#
	# This command is ignored in shells other than zsh.
	#
	unsetopt GLOB NO_MATCH NO_SH_WORD_SPLIT >/dev/null 2>&1 || :
fi
# --- 4174138 --- env:entrypoint
entrypoint='coral'
# --- 4174138 --- func:require
require () ( : )
require_source ()
{
    if test -z "${1:-}"
    then
        return
        elif test "${1}" = "shell/vars.sh"
    then
        cat <<'FILESOURCE_SNIPPET'
shell_vars ()
{
	shell_vars_fill | sort -n
}

shell_vars_fill ()
{
	shell_var_line=''
	shell_var_value=''

	if test -n "${POSH_VERSION-}"
	then
		while read -r shell_var_line
		do
			shell_var_value="$(eval printf %s "\${${shell_var_line}}")"
			printf %s\\n "${shell_var_line}='${shell_var_value}'"
		done
		return
	fi

	while read -r shell_var_line
	do
		if test "${shell_var_line%% ()} ()" = "${shell_var_line}" &&
		   test "${shell_var_line#*=}" != "${shell_var_line}"
		then
			return
		fi
		printf %s\\n "${shell_var_line}"
	done
}
FILESOURCE_SNIPPET
    elif test "${1}" = "require.sh"
    then
        cat <<'FILESOURCE_SNIPPET'
##
 # require.sh - a portable shell script file loader
 ##

require ()
{
	local suffix=".sh"
	local previous="${dependency:-require}"
	local dependency="${1}"
	shift

	require_loaded="${require_loaded:- }"

	if require_is_loaded "${dependency}" "${previous}" "${@:-}"
	then
		return 0
	fi

	if ! require_include "${dependency}" "${@:-}"
	then
		echo "Could not find dependency '${dependency}'"
		return $?
	fi
}

require_on_include ()
{
	local required_file="${1}"

	test "${dependency%*${suffix}}${suffix}" = "${dependency}" || return 0

	set --
	. "${required_file}"
}

require_on_request ()
{
	local dependency="${1}"

	if test "${require_loaded#* ${dependency} *}" = "${require_loaded}"
	then
		return 1
	fi
}

require_on_search ()
{
	require_path "${1}"
}

require_path ()
{
	local solved
	local target_path="${2:-${require_path:-}}"
	local IFS=':'

	for solved in ${target_path}
	do
		if test -f "${solved}/${1}"
		then
			printf %s "${solved}/${1}"
			return
		fi
	done
}

require_include ()
{
	local dependency="${1}"
	shift
	local location="$(
		${require_on_search:-require_on_search} "${dependency}" "${@:-}"
	)"

	test -f "${location}" || return 69

	require_loaded="${require_loaded:- }${dependency} "

	${require_on_include:-require_on_include} "${location}" "${dependency}" "${@:-}" ||
		return 1
}

require_is_loaded ()
{
	dependency="${1}"
	previous="${2}"
	require_loaded="${require_loaded:- }"

	${require_on_request:-require_on_request} "${@:-}"
}

require_source ()
{
	cat "$(require_path "${1}")"
}
FILESOURCE_SNIPPET
    elif test "${1}" = "module/entrypoint"
    then
        cat <<'FILESOURCE_SNIPPET'
#!/usr/bin/env sh

##
 # require entrypoint - a modular command runner
 ##

# Run command named by the entrypoint variable or nothing (the : command)
${entrypoint:-:} "${@:-}"
FILESOURCE_SNIPPET
    elif test "${1}" = "module/support"
    then
        cat <<'FILESOURCE_SNIPPET'
#!/usr/bin/env sh

##
 # require support - silently set sane options for all shells
 ##

# Options for all shells
#
# -e: Exit if any command has an uncaught error code
# -u: Exit on any use of an undefined variable
# -f: Do not expand glob patterns
set -euf

# Mimic local variables on ksh by aliasing it to typeset
#
# This command is ignored by shells other than ksh
#
if ( test -n "${KSH_VERSION:-}" &&
     test -z "${KSH_VERSION##*Version AJM*}" ) ||
     test -n "${YASH_VERSION:-}"
then
	alias local=typeset
elif test -n "${BASH_VERSION-}"
then
	set -o posix
elif test -n "${ZSH_VERSION-}"
then
	# Unset options for zsh to make it more portable
	#
	# NO_MATCH: Avoid expanding extra filename patterns
	# NO_SH_WORD_SPLIT: Make the word split on zsh behave like POSIX
	#
	# This command is ignored in shells other than zsh.
	#
	unsetopt GLOB NO_MATCH NO_SH_WORD_SPLIT >/dev/null 2>&1 || :
fi
FILESOURCE_SNIPPET
    else
        cat "$(require_path "${1}")"
    fi
}
# --- 4174138 --- file:lib/require.sh
##
 # require.sh - a portable shell script file loader
 ##

require ()
{
	local suffix=".sh"
	local previous="${dependency:-require}"
	local dependency="${1}"
	shift

	require_loaded="${require_loaded:- }"

	if require_is_loaded "${dependency}" "${previous}" "${@:-}"
	then
		return 0
	fi

	if ! require_include "${dependency}" "${@:-}"
	then
		echo "Could not find dependency '${dependency}'"
		return $?
	fi
}

require_on_include ()
{
	local required_file="${1}"

	test "${dependency%*${suffix}}${suffix}" = "${dependency}" || return 0

	set --
	. "${required_file}"
}

require_on_request ()
{
	local dependency="${1}"

	if test "${require_loaded#* ${dependency} *}" = "${require_loaded}"
	then
		return 1
	fi
}

require_on_search ()
{
	require_path "${1}"
}

require_path ()
{
	local solved
	local target_path="${2:-${require_path:-}}"
	local IFS=':'

	for solved in ${target_path}
	do
		if test -f "${solved}/${1}"
		then
			printf %s "${solved}/${1}"
			return
		fi
	done
}

require_include ()
{
	local dependency="${1}"
	shift
	local location="$(
		${require_on_search:-require_on_search} "${dependency}" "${@:-}"
	)"

	test -f "${location}" || return 69

	require_loaded="${require_loaded:- }${dependency} "

	${require_on_include:-require_on_include} "${location}" "${dependency}" "${@:-}" ||
		return 1
}

require_is_loaded ()
{
	dependency="${1}"
	previous="${2}"
	require_loaded="${require_loaded:- }"

	${require_on_request:-require_on_request} "${@:-}"
}

require_source ()
{
	cat "$(require_path "${1}")"
}
# --- 4174138 --- file:lib/math/random.sh

math_random ()
{
	echo ${RANDOM:-$(od -An -N3 -i /dev/random)}
}
# --- 4174138 --- file:lib/fs/tempdir.sh

require 'math/random.sh'

fs_tempdir ()
{
	local prefix="${1:-tempdir.sh}"
	local systmp="${TMPDIR:-/tmp}"
    local tempdir="$(mktemp -d "${systmp}/${prefix}.XXXXXX" 2>/dev/null || :)"

    if test -z "${tempdir:-}"
	then
		tempdir="${systmp}/${prefix}.$(math_random)"
	    mkdir -m 'u+rwx' "${tempdir}"
	fi

	echo "${tempdir}"
}
# --- 4174138 --- file:lib/shell/pipe.sh
# https://unix.stackexchange.com/questions/76162/how-do-i-capture-the-return-status-and-use-tee-at-the-same-time-in-korn-shell

shell_pipe ()
{
	local argument
	local cursor=1
	local position=1
	local shell_pipe_status=0
	local callback=
	local current_chunk=

	# Creates the code to nest redirects between the commands
	for argument in "${@:-}"
	do
		case ${argument} in
			( '--' )
				callback="
					${callback} {
						${current_chunk} 3>&-
						echo shell_pipe_status_${cursor}=\$? >&3
					} 4>&- |
				"
				cursor=$((${cursor}+1))
				current_chunk=
				;;
			( * )
				current_chunk="${current_chunk} \"\${${position}}\""
				;;
		esac

		position=$((${position}+1))
	done

	# Runs the pipes
	{ eval "$(
			exec 3>&1
			eval "
				${callback} ${current_chunk} 3>&- >&4 4>&-
				echo shell_pipe_status=\$?
			"
		)"
	} 4>&1

	return "${shell_pipe_status}"
}
# --- 4174138 --- file:lib/shell/route.sh
shell_route ()
{
	local namespace="${1}"
	local argument="${2:-}"
	local short
	local long
	local long_name
	local long_value
	local target
	local returned

	if test "" = "${argument}"
	then
		"${namespace}_${shell_route_default:-empty_command}"
		return $?
	fi

	short="${argument#*-}"
	long="${short#*-}"

	shift 2

	if test "${argument}" = "--${long}"
	then
		long_name="${long%%=*}"

		if test "${long}" != "${long_name}"
		then
			long_value="${long#*=}"
			long="${long_name}"
			set -- "${long_value}" "${@:-}"
		fi

		target="${namespace}_${shell_route_option:-option_}${long}"
	elif test "${argument}" = "-${short}"
	then
		target="${namespace}_${shell_route_option:-option}_${short}"
	elif test -z "${shell_route_options_only:-}"
	then
		target="${namespace}_${shell_route_command:-command}_${long}"
	else
		return 1
	fi

	set -- "${target:-:}" "${@:-}"

	if test -n "${shell_route_name:-}"
	then
		echo "${@:-}"
		return
	fi

	"${@:-}"
}
# --- 4174138 --- file:lib/shell/vars.sh
eval "$(require_source shell/vars.sh)"
# --- 4174138 --- file:lib/spec.sh
require 'fs/tempdir.sh'
require 'shell/pipe.sh'
require 'shell/route.sh'
require 'shell/vars.sh' --assemble-source

spec ()
{
	if test -n "${1:-}" && test -f "${1}"
	then
		spec_command_run "${@:-}"
		return
	fi

	shell_route 'spec' "${@:-}"
}

spec_option_help ()
{
	cat <<-HELPTEXT
		Usage: spec [ARGUMENTS] FILES...

		Options:
		  --help     Displays this help
		  --version  Displays version information

		FILES... must be one or more Markdown files containing shell code
		examples.

	HELPTEXT
}

spec_command_run ()
{
	local spec_shell="${spec_shell:-sh}"
	local test_number=0
	local fail_number=0
	local test_result=0
	local oldifs="${IFS}"
	local target_files="${*:-}"
	local tempdir=

	echo "# using	'${spec_shell:-sh}'"

	if test -z "${target_files}"
	then
		echo "# "
		echo "# FAILURE (no .md files found)"
		test_result=1
		return
	fi

	target_files="$(printf %s\\n ${target_files} | sort)"

	tempdir="$(fs_tempdir 'spec')"

	echo "# "

	cp -R "${PWD}" "${tempdir}/pwd"

	for target_file in ${target_files}
	do
		if test ! -f "${target_file}"
		then
			continue
		fi
		echo "# file	'${target_file}'"
		mkdir -p "${tempdir}/${target_file}.workspace"
		cp -R "${tempdir}/pwd/." "${tempdir}/${target_file}.workspace"
		spec_parse "${tempdir}/${target_file}.workspace" "${target_file}"
	done

	if test "${fail_number}" -gt 0
	then
		echo "# FAILURE (${fail_number} of ${test_number} assertions failed)"
		echo "1..${test_number}"
		test_result=1
	elif test "${test_number}" -gt 0
	then
		echo "# SUCCESS"
		echo "1..${test_number}"
	else
		echo "# FAILURE (no tests found)"
		test_result=1
	fi

	return "${test_result}"
}

spec_parse ()
{
	local spec_directory="${1}"
	local line=
	local open_fence=
	local possible_fence=
	local line_number=1
	local line_last_open_fence=0
	local setup='true'
	local oldifs="${IFS}"

	mkdir -p "${spec_directory}/.spec"

	IFS=''
	while read -r line
	do
		IFS="${oldifs}"
		possible_fence="${line#*\`\`\`}"

		if test -z "${open_fence}"
		then
			if test "${line}" = "\`\`\`${possible_fence}"
			then
				open_fence="${possible_fence}"
				line_last_open_fence="${line_number}"
				_spec_fence_open ${open_fence}
			else
				_spec_text_line ${open_fence}
			fi
		else
			if test "${line}" = "\`\`\`${possible_fence}"
			then
				_spec_fence_close ${open_fence}
				open_fence=
			else
				_spec_fence_line ${open_fence}
			fi
		fi

		line_number=$((line_number + 1))
		IFS=''
	done < "${2}"
	IFS="${oldifs}"
}

_spec_fence_open ()
{
	local language="${1:-}"
	local key="${2:-}"
	local value="${3:-}"
	local file_path=''

	if test "file" = "${key}"
	then
		file_path="${spec_directory}/${value}"
		if test "$(basename "${file_path}")" != "${file_path}"
		then
			mkdir -p "$(dirname "${file_path}")"
		fi
		printf '' > "${file_path}"
	elif test "console" = "${language}" &&
		 test ! -z "${key}"
	then
		printf '' > "${spec_directory}/.spec/console"
	elif test "setup" = "${key}" && test "${language}" != "console"
	then
		printf '' > "${spec_directory}/.spec/setup"
	fi
}

_spec_fence_line ()
{
	local language="${1:-}"
	local key="${2:-}"
	local value="${3:-}"

	if test "file" = "${key}"
	then
		echo "$line" >> "${spec_directory}/${value}"
	elif test "console" = "${language}" &&
		 test ! -z "${key}"
	then
		echo "$line" >> "${spec_directory}/.spec/console"
	elif test "setup" = "${key}" && test "${language}" != "console"
	then
		echo "$line" >> "${spec_directory}/.spec/setup"
	fi
}

_spec_fence_close ()
{
	local language="${1:-}"
	local key="${2:-}"
	local value="${3:-}"

	if test "console" = "${language}" &&
	   test "test" = "${key}"
	then
		_spec_run_console _spec_report_single_result
	elif test "console" = "${language}" &&
	     test "task" = "${key}"
	then
		_spec_run_console _spec_report_code_result
	elif test "setup" = "${key}" && test "${language}" != "console"
	then
		_spec_collect_setup
	fi
}

_spec_collect_setup ()
{
	setup="$(cat "${spec_directory}/.spec/setup")"
}

_spec_run_console ()
{
	local assertion="${1:-_spec_report_single_result}"
	local previous_dir="${PWD}"
	local message=
	local instructions=
	local result=true
	local result_code=0
	local expectation=
	local expectation_lines=0
	local message_line=1
	local last_command_line=0
	local oldifs="${IFS}"

	cd "${spec_directory}"
	printf '' > "${spec_directory}/.spec/varset"
	printf '' > "${spec_directory}/.spec/varprev"
	printf '' > "${spec_directory}/.spec/varnext"

	IFS=''
	while read -r message
	do
		IFS="${oldifs}"
		if test "\$ \# ${message#*\$ \# }" = "${message}"
		then
			_spec_report_comment
		elif test "\$ ${message#*\$ }" = "${message}"
		then
			${assertion}
			last_command_line="${message_line}"
			instructions="${message#*\$ }"
			test_number=$((test_number + 1))
			set +e
			shell_pipe _spec_run_external --\
			     tee "${spec_directory}/.spec/result" --\
			     cat 1>/dev/null 2>&1
			result_code="${shell_pipe_status_1}"
			set -e
			result="$(cat "${spec_directory}/.spec/result" | _spec_import_result)"

			expectation=
		else
			_spec_collect_expectation
		fi
		message_line=$((message_line + 1))
		IFS=''
	done < "${spec_directory}/.spec/console"
	IFS="${oldifs}"

	${assertion}
	instructions="${message#*\$ }"

	cd "${previous_dir}"
}

_spec_import_result ()
{
	sed 's/.*/# - &$/'
}

_spec_run_external ()
{
	${spec_shell:-sh} <<-EXTERNAL 2>&1
		$(require_source 'shell/vars.sh')
		. "${spec_directory}/.spec/varset"
		PATH="\${PATH}:."
		SHELL="${spec_shell}"
		TERM=
		${setup}
		_spec_return () ( return "${result_code}" )
		set | shell_vars > "${spec_directory}/.spec/varprev"
		test '0' = "${result_code}" || _spec_return
		${instructions}
		external_code=\$?
		set | shell_vars > "${spec_directory}/.spec/varnext"
		comm -3 -1 \
			"${spec_directory}/.spec/varprev" \
			"${spec_directory}/.spec/varnext" 2>/dev/null |
			sed '/^LINENO/d' >> "${spec_directory}/.spec/varset"
		exit \${external_code}
	EXTERNAL
}

_spec_collect_expectation ()
{
	if test -z "${expectation}" && test -z "${message}"
	then
		expectation="# - $(printf \\n)$"
	elif test -z "${expectation}"
	then
		expectation="$(printf %s\\n "# - ${message}$")"
	else
		expectation="$(printf %s\\n "${expectation}" "# - ${message}$")"
	fi

	expectation_lines=$((expectation_lines + 1))
}

_spec_report_single_result ()
{
	local line_report="${test_number} - ${instructions}"

	if test "${expectation}" = "${result}"
	then
		echo "ok	${line_report}"
		instructions=
	elif test ! -z "${instructions}"
	then
		fail_number=$((fail_number + 1))
		error_line=$((${line_last_open_fence} + ${last_command_line:-}))
		echo
		echo "not ok	${line_report}"
		echo "# Failure on ${target_file} line ${error_line}"
		echo "# Output"
		echo "${result}" | sed 's/# - \([^$]*\)\$/#	\1/'
		echo "# Expected"
		echo "${expectation}" | sed 's/# - \([^$]*\)\$/#	\1/'
		echo
	fi
}

_spec_report_code_result ()
{
	local line_report="${test_number} - ${instructions}"

	if test -z "${instructions}"
	then
		return
	fi

	if test '0' = "${result_code}"
	then
		echo "ok	${line_report}"
		instructions=
	else
		fail_number=$((fail_number + 1))
		error_line=$((${line_last_open_fence} + ${last_command_line:-}))
		echo
		echo "not ok	${line_report}"
		echo "# Failure on ${target_file} line ${error_line}"
		echo "# Output"
		echo "${result}" | sed 's/# - \([^$]*\)\$/#	\1/'
		echo "# Exit Code: ${result_code}"
		echo
	fi
}

_spec_text_line ()
{
	:
}

_spec_report_comment ()
{
	:
}
# --- 4174138 --- file:lib/require.sh
eval "$(require_source require.sh)"
# --- 4174138 --- file:lib/math/random.sh

math_random ()
{
	echo ${RANDOM:-$(od -An -N3 -i /dev/random)}
}
# --- 4174138 --- file:lib/math/random.sh

math_random ()
{
	echo ${RANDOM:-$(od -An -N3 -i /dev/random)}
}
# --- 4174138 --- file:lib/fs/tempdir.sh

require 'math/random.sh'

fs_tempdir ()
{
	local prefix="${1:-tempdir.sh}"
	local systmp="${TMPDIR:-/tmp}"
    local tempdir="$(mktemp -d "${systmp}/${prefix}.XXXXXX" 2>/dev/null || :)"

    if test -z "${tempdir:-}"
	then
		tempdir="${systmp}/${prefix}.$(math_random)"
	    mkdir -m 'u+rwx' "${tempdir}"
	fi

	echo "${tempdir}"
}
# --- 4174138 --- file:lib/assemble.sh
##
 # assemble.sh
 ##

require 'require.sh' --assemble-source
require 'module/entrypoint' --assemble-source
require 'module/support' --assemble-source
require 'math/random.sh'
require 'fs/tempdir.sh'

assemble ()
{
	shell_route_options_only=true shell_route 'assemble' "${@:-}" ||
		assemble_bundle "${@:-}"
}

assemble_option_help ()
{
	cat <<-HELPTEXT
		Usage: assemble [ARGUMENTS] MODULE OUTPUT_FILE

		Options:
		  --help     Displays this help
		  --version  Displays version information

		MODULE can be any require.sh compatible module in the current
		require_path.

		OUTPUT_FILE must be a path for the output executable file.

	HELPTEXT
}

assemble_bundle ()
{
	local assemble_key="$(math_random)"
	local input="${1:-}"
	local output="${2:--}"
	local assemble_dir="$(fs_tempdir 'assemble')"

	printf '' > "${assemble_dir}/sources"
	assemble_contents "${input}" > "${assemble_dir}/output"

	if test "-" = "${output}"
	then
		cat "${assemble_dir}/output"
	else
		chmod +x "${assemble_dir}/output"
		cp "${assemble_dir}/output" "${output}"
	fi
}

assemble_contents ()
{
	local input="${1:-}"
	local input_file="$(echo "${input}" | tr '_' '/').sh"
	local input_contents=''
	local require_loaded=' '

	echo "#!/usr/bin/env sh"

	echo "# --- ${assemble_key} --- file:module/support"
	require_source 'module/support'

	echo "# --- ${assemble_key} --- env:entrypoint"
	echo "entrypoint='${input}'"

	assemble_dependencies "${input_file}"

	echo "# --- ${assemble_key} --- file:module/entrypoint"
	require_source 'module/entrypoint'
}

assemble_dependencies ()
{
	local require_on_include='assemble_on_include'
	local require_on_request='assemble_on_request'
	local input_file="${1:-}"
	local require_sources=

	require "${input_file}" > "${assemble_dir}/required_modules"

	if require_is_loaded "require.sh" ""
	then
		echo "# --- ${assemble_key} --- env:require_loaded"
		echo "require_loaded='${require_loaded}'"
		echo "# --- ${assemble_key} --- env:require_path"
		echo "require_path='${assemble_path:-${require_path}}'"
		echo "# --- ${assemble_key} --- file:require.sh"
		require_source 'require.sh'
	else
		echo "# --- ${assemble_key} --- func:require"
		echo 'require () ( : )'
	fi

	require_sources="$(cat "${assemble_dir}/sources")"

	if test -n "${require_sources}"
	then
		cat <<-SOURCES_SNIPPET
			require_source ()
			{
			    if test -z "\${1:-}"
			    then
			        return
			    ${require_sources}
			    else
			        cat "\$(require_path "\${1}")"
			    fi
			}
		SOURCES_SNIPPET
	fi
	cat "${assemble_dir}/required_modules"
}


assemble_on_include ()
{
	local target="${1}"
	local target_name="$(basename ${target})"
	local dependency="${2:-}"
	shift 2
	local contents

	contents="$(cat "${target}")"

	test "${target_name%*.sh}.sh" = "${target_name}" || return 0

	require_on_include "${target}"
	echo "# --- ${assemble_key} --- file:${target}"

	if test "${#}" -gt 0 && test "${*#*--assemble-source*}" != "${*:-}"
	then
		echo "eval \"\$(require_source ${dependency})\""
	else
		printf %s\\n "${contents}"
	fi
}


assemble_on_request ()
{
	local dependency="${1}"
	local previous="${2}"
	shift 2

	if test "${#}" -gt 0 && test "${*#*--assemble-source*}" != "${*:-}"
	then
		cat <<-SOURCES_SNIPPET >> "${assemble_dir}/sources"
			    elif test "\${1}" = "${dependency}"
			    then
			        cat <<'FILESOURCE_SNIPPET'
						$(require_source "${dependency}")
					FILESOURCE_SNIPPET
		SOURCES_SNIPPET
	fi

	require_on_request "${target}" "${@:-}"
}
# --- 4174138 --- file:lib/shell/route.sh
shell_route ()
{
	local namespace="${1}"
	local argument="${2:-}"
	local short
	local long
	local long_name
	local long_value
	local target
	local returned

	if test "" = "${argument}"
	then
		"${namespace}_${shell_route_default:-empty_command}"
		return $?
	fi

	short="${argument#*-}"
	long="${short#*-}"

	shift 2

	if test "${argument}" = "--${long}"
	then
		long_name="${long%%=*}"

		if test "${long}" != "${long_name}"
		then
			long_value="${long#*=}"
			long="${long_name}"
			set -- "${long_value}" "${@:-}"
		fi

		target="${namespace}_${shell_route_option:-option_}${long}"
	elif test "${argument}" = "-${short}"
	then
		target="${namespace}_${shell_route_option:-option}_${short}"
	elif test -z "${shell_route_options_only:-}"
	then
		target="${namespace}_${shell_route_command:-command}_${long}"
	else
		return 1
	fi

	set -- "${target:-:}" "${@:-}"

	if test -n "${shell_route_name:-}"
	then
		echo "${@:-}"
		return
	fi

	"${@:-}"
}
# --- 4174138 --- file:lib/coral.sh
##
 # coral.sh
 ##

require 'require.sh'
require 'spec.sh'
require 'assemble.sh'
require 'shell/route.sh'

coral ()
{
	if test -z "${1:-}"
	then
		echo "No arguments. Try ${0} --help" 1>&2
		return 1
	fi

	shell_route_options_only=true shell_route 'coral' "${@:-}" ||
		coral_run "${@:-}"
}

coral_run ()
{
	local require_path="${require_path:-}${require_path:+:.}"
	local target="${1:-}"
	local target_file="$(echo "${target}" | tr '_' '/').sh"
	shift

	require "${target_file}"
	"${target}" "${@:-}"
}

coral_option_help ()
{
	cat <<-HELPTEXT
		Usage: coral [ARGUMENTS] COMMAND
		       coral [ARGUMENTS] MODULE

		Commands:
		  status      Displays coral context status
		  spec        Runs tests from specifications
		  assemble    Builds shell script executable bundles

		Options:
		  --help      Displays this help
		  --version   Displays version information

		MODULE can be any require.sh compatible module in the current
		require_path.

	HELPTEXT
}
# --- 4174138 --- file:module/entrypoint
#!/usr/bin/env sh

##
 # require entrypoint - a modular command runner
 ##

# Run command named by the entrypoint variable or nothing (the : command)
${entrypoint:-:} "${@:-}"
